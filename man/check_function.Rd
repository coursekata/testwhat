% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/check-function.R
\name{check_function}
\alias{check_function}
\alias{check_operator}
\alias{check_arg}
\alias{check_equal.ArgumentState}
\title{Check whether a student correctly called a function/operator}
\usage{
check_function(state, name, index = 1, not_called_msg = NULL, append = TRUE)

check_operator(state, name, index = 1, append = TRUE, not_called_msg = NULL)

check_arg(state, arg, arg_not_specified_msg = NULL, append = TRUE)

\method{check_equal}{ArgumentState}(
  state,
  incorrect_msg = NULL,
  eval = TRUE,
  eq_condition = "equivalent",
  eq_fun = NULL,
  append = TRUE,
  ...
)
}
\arguments{
\item{state}{state to start from}

\item{name}{name of the function/operator as a string, e.g. \code{"mean"} or
\code{"+"}}

\item{index}{integer that specifies which call of \code{name} in the
solution code will be checked.}

\item{not_called_msg}{custom feedback message in case the student did not
call the function often enough.}

\item{append}{Whether or not to append the feedback to feedback built in
previous states}

\item{arg}{name or position of argument to specify
... Arguments can be accessed using '..<INDEX>' (see example 5) (for \code{check_arg})}

\item{arg_not_specified_msg}{custom message in case argument was not
specified (for \code{check_arg})}

\item{incorrect_msg}{custom feedback message in case the student did not call
the function with the same argument values as in the sample solution. You
can specify a vector of arguments with the same length as \code{args}, to
have argument-specific custom feedback.}

\item{eval}{logical vector indicating whether and how to compare arguments.
If \code{eval} is \code{NA}, student and solution argument are not
compared. If \code{eval} is \code{FALSE}, the string versions of the
arguments are compared. If \code{eval} is \code{TRUE}, the argument in the
student code is evaluated in the student environment and the argument in
the solution code is evaluated in the solution environment, and their
results are compared. Setting this to \code{FALSE} can be useful, e.g., to
check whether the student supplied a large predefined object, or when
you're in a sub-SCT where the environments are not unambiguously available.}

\item{eq_condition}{character vector indicating how to perform the
comparison for each argument. See \code{\link{is_equal}}.}

\item{eq_fun}{optional argument to specify a custom equality function. The
function should take two arguments and always return a single boolean
value: \code{TRUE} or \code{FALSE}.}

\item{...}{S3 stuff}
}
\description{
Check whether a student called a function correctly. Note:
\code{test_function} and \code{test_function_v2} are now identical and either
can be used.
}
\examples{
\dontrun{
# Example 1
mean(1:3)

# SCT
ex() \%>\% check_function("mean") \%>\% check_arg("x") \%>\% check_equal()

# Example 2
mean(c(NA, 1, 2), na.rm = TRUE)

# SCT
ex() \%>\% check_function("mean") \%>\% {
  check_arg(., "x") \%>\% check_equal()
  check_arg(., "na.rm") \%>\% check_equal()
}

# Example 3
5 + 4

# SCT
ex() \%>\% check_operator("+") \%>\% check_result() \%>\% check_equal()

# Example 4: Positional argument check
cor(rnorm(10), rnorm(10))

# SCT
ex() \%>\% check_function("cor") \%>\% {
  check_arg(., 1) \%>\% check_equal()
  check_arg(., 2) \%>\% check_equal()
}

# Example 5: ... in check_args

soln <- "std_dev <- purrr::compose(sqrt, var, .dir='forward')"
state <- setup_state(soln, soln)
state \%>\% check_function(., "compose") \%>\% {
  check_arg(., '..1') \%>\% check_equal() # sqrt
  check_arg(., '..2') \%>\% check_equal() # var
  check_arg(., '.dir') \%>\% check_equal()
}

}
}
